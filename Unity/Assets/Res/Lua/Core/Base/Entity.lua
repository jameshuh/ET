-- Generated by CSharp.lua Compiler
local System = System
local DCETRuntime = DCET.Runtime
local UnityEngine = UnityEngine
local DCET
local HashSetEntity
local DictTypeEntity
local DictInt64Entity
local Pool_1HashSetEntity
local Pool_1DictTypeEntity
local Pool_1DictInt64Entity
System.import(function (out)
  DCET = out.DCET
  HashSetEntity = System.HashSet(DCET.Entity)
  DictTypeEntity = System.Dictionary(System.Type, DCET.Entity)
  DictInt64Entity = System.Dictionary(System.Int64, DCET.Entity)
  Pool_1HashSetEntity = DCET.Pool_1(HashSetEntity)
  Pool_1DictTypeEntity = DCET.Pool_1(DictTypeEntity)
  Pool_1DictInt64Entity = DCET.Pool_1(DictInt64Entity)
end)
System.namespace("DCET", function (namespace)
  namespace.class("EntityStatus", function (namespace)
    return {
      None = 0,
      IsFromPool = 1,
      IsRegister = 2,
      IsComponent = 4
    }
  end)

  namespace.class("Entity", function (namespace)
    local hashSetPool, dictPool, childrenPool, Global, getIsFromPool, setIsFromPool, getIsRegister, setIsRegister, 
    getIsComponent, setIsComponent, getIsDisposed, getParent, setParent, setComponentParent, AfterSetParent, GetParent, 
    ToString, getDomain, setDomain, getChildren, AddChild, RemoveChild, AddChildDB, RemoveChildDB, 
    getComponents, Dispose, EndInit, AddToComponentsDB, RemoveFromComponentsDB, AddToComponent, RemoveFromComponent, AddComponentWithInstance, 
    AddComponentWithType, AddComponent, AddComponent1, AddComponent2, AddComponent3, AddComponentNoPool, AddComponentNoPool1, AddComponentNoPool2, 
    AddComponentNoPool3, RemoveComponent, RemoveComponentWithInstance, RemoveComponentWithType, GetComponent, GetComponentWithType, CreateWithComponentParent, CreateWithComponentParent1, 
    CreateWithComponentParent2, CreateWithComponentParent3, CreateWithComponentParent4, class, static, __ctor__
    static = function (this)
      hashSetPool = Pool_1HashSetEntity()
      dictPool = Pool_1DictTypeEntity()
      childrenPool = Pool_1DictInt64Entity()
      Global = UnityEngine.GameObject.Find("Game")
      this.Global = Global
    end
    __ctor__ = function (this)
      this.status = DCET.EntityStatus.None
      this.InstanceId = DCET.IdGenerater.GenerateId()


      if not this:GetType():IsDefined(System.typeof(DCET.HideInHierarchy), true) then
        this.ViewGO = UnityEngine.GameObject()
        this.ViewGO:setname(this:GetType():getName())
        this.ViewGO:setlayer(DCET.LayerNames.GetLayerInt("Hidden" --[[LayerNames.HIDDEN]]))
        this.ViewGO:gettransform():SetParent(Global:gettransform(), false)
        local componentView = System.as(this.ViewGO:AddComponent(System.typeof(DCETRuntime.ComponentView)), DCETRuntime.ComponentView)

        if UnityEngine.op_Implicit(componentView) then
          componentView:setComponent(this)
        end
      end
    end
    getIsFromPool = function (this)
      return (System.band(this.status, DCET.EntityStatus.IsFromPool)) == DCET.EntityStatus.IsFromPool
    end
    setIsFromPool = function (this, value)
      if value then
        this.status = System.bor(this.status, DCET.EntityStatus.IsFromPool)
      else
        this.status = System.band(this.status, System.bnot(DCET.EntityStatus.IsFromPool))
      end

      if this.InstanceId == 0 then
        this.InstanceId = DCET.IdGenerater.GenerateId()
      end

      setIsRegister(this, value)
    end
    getIsRegister = function (this)
      return (System.band(this.status, DCET.EntityStatus.IsRegister)) == DCET.EntityStatus.IsRegister
    end
    setIsRegister = function (this, value)
      if getIsRegister(this) == value then
        return
      end
      if value then
        this.status = System.bor(this.status, DCET.EntityStatus.IsRegister)
      else
        this.status = System.band(this.status, System.bnot(DCET.EntityStatus.IsRegister))
      end
      DCET.Game.getEventSystem():RegisterSystem(this, value)
    end
    getIsComponent = function (this)
      return (System.band(this.status, DCET.EntityStatus.IsComponent)) == DCET.EntityStatus.IsComponent
    end
    setIsComponent = function (this, value)
      if value then
        this.status = System.bor(this.status, DCET.EntityStatus.IsComponent)
      else
        this.status = System.band(this.status, System.bnot(DCET.EntityStatus.IsComponent))
      end
    end
    getIsDisposed = function (this)
      return this.InstanceId == 0
    end
    getParent = function (this)
      return this.parent
    end
    setParent = function (this, value)
      if value == nil then
        System.throw(System.Exception("cant set parent null: " .. this:GetType():getName()))
      end

      if this.parent ~= nil then
        -- parent相同，不设置
        if this.parent.InstanceId == value.InstanceId then
          DCET.Log.Error1("重复设置了Parent: " .. this:GetType():getName() .. " parent: " .. this.parent:GetType():getName())
          return
        end

        RemoveChild(this.parent, this)

        this.parent = value
        AddChild(this.parent, this)

        setDomain(this, this.parent.domain)
      else
        this.parent = value
        AddChild(this.parent, this)

        setIsComponent(this, false)

        AfterSetParent(this)
      end
    end
    setComponentParent = function (this, value)
      if this.parent ~= nil then
        System.throw(System.Exception("Component parent is null: " .. this:GetType():getName()))
      end

      this.parent = value

      setIsComponent(this, true)

      AfterSetParent(this)
    end
    AfterSetParent = function (this)
      if this.parent.domain ~= nil then
        setDomain(this, this.parent.domain)
      end

      -- 检测自己的domain是不是跟父亲一样
      if getDomain(this) ~= nil and getDomain(this.parent) ~= nil and getDomain(this).InstanceId ~= getDomain(this.parent).InstanceId and not (System.is(this, DCET.Scene)) then
        DCET.Log.Error1("自己的domain跟parent不一样: " .. this:GetType():getName())
      end

      if UnityEngine.op_Inequality(this.ViewGO, nil) and UnityEngine.op_Inequality(this.parent.ViewGO, nil) then
        this.ViewGO:gettransform():SetParent(this.parent.ViewGO:gettransform(), false)
      end
    end
    GetParent = function (this, T)
      return System.as(getParent(this), T)
    end
    ToString = function (this)
      return DCET.MongoHelper.ToJson(this)
    end
    getDomain = function (this)
      return this.domain
    end
    setDomain = function (this, value)
      if value == nil then
        return
      end

      local preDomain = this.domain
      this.domain = value

      if not (System.is(this.domain, DCET.Scene)) then
        System.throw(System.Exception("domain is not scene: " .. this:GetType():getName()))
      end

      this.domain = value

      -- 是否注册跟parent一致
      if this.parent ~= nil then
        setIsRegister(this, getIsRegister(getParent(this)))
      end

      -- 递归设置孩子的Domain
      if this.children ~= nil then
        for _, entity in System.each(this.children:getValues()) do
          setDomain(entity, this.domain)
        end
      end

      if this.components ~= nil then
        for _, component in System.each(this.components:getValues()) do
          setDomain(component, this.domain)
        end
      end

      if preDomain == nil and not getIsFromPool(this) then
        DCET.Game.getEventSystem():Deserialize(this)
      end
    end
    getChildren = function (this)
      if this.children == nil then
        this.children = childrenPool:Fetch()
      end

      return this.children
    end
    AddChild = function (this, entity)
      getChildren(this):AddKeyValue(entity.Id, entity)
      AddChildDB(this, entity)
    end
    RemoveChild = function (this, entity)
      if this.children == nil then
        return
      end

      this.children:RemoveKey(entity.Id)

      if this.children:getCount() == 0 then
        childrenPool:Recycle(this.children)
        this.children = nil
      end
      RemoveChildDB(this, entity)
    end
    AddChildDB = function (this, entity)
      if not (System.is(entity, DCET.ISerializeToEntity)) then
        return
      end
      if this.childrenDB == nil then
        this.childrenDB = hashSetPool:Fetch()
      end
      this.childrenDB:Add(entity)
    end
    RemoveChildDB = function (this, entity)
      if not (System.is(entity, DCET.ISerializeToEntity)) then
        return
      end

      if this.childrenDB == nil then
        return
      end

      this.childrenDB:Remove(entity)

      if this.childrenDB:getCount() == 0 then
        if getIsFromPool(this) then
          hashSetPool:Recycle(this.childrenDB)
          this.childrenDB = nil
        end
      end
    end
    getComponents = function (this)
      return this.components
    end
    Dispose = function (this)
      if getIsDisposed(this) then
        return
      end

      local instanceId = this.InstanceId
      this.InstanceId = 0

      DCET.Game.getEventSystem():Remove(instanceId)

      -- 触发Destroy事件
      DCET.Game.getEventSystem():Destroy(this)

      this.domain = nil

      -- 清理Children
      if this.children ~= nil then
        local deletes = this.children
        this.children = nil

        for _, child in System.each(deletes:getValues()) do
          child:Dispose()
        end

        deletes:Clear()
        childrenPool:Recycle(deletes)

        if this.childrenDB ~= nil then
          this.childrenDB:Clear()
          -- 从池中创建的才需要回到池中,从db中不需要回收
          if getIsFromPool(this) then
            hashSetPool:Recycle(this.childrenDB)
            this.childrenDB = nil
          end
        end
      end

      -- 清理Component
      if this.components ~= nil then
        local deletes = this.components
        this.components = nil
        for _, kv in System.each(deletes) do
          kv.Value:Dispose()
        end

        deletes:Clear()
        dictPool:Recycle(deletes)

        -- 从池中创建的才需要回到池中,从db中不需要回收
        if this.componentsDB ~= nil then
          this.componentsDB:Clear()

          if getIsFromPool(this) then
            hashSetPool:Recycle(this.componentsDB)
            this.componentsDB = nil
          end
        end
      end

      if getIsComponent(this) then
        local default = this.parent
        if default ~= nil then
          RemoveComponentWithInstance(default, this)
        end
      else
        local default = this.parent
        if default ~= nil then
          RemoveChild(default, this)
        end
      end

      this.parent = nil

      if getIsFromPool(this) then
        DCET.Game.getObjectPool():Recycle(this)
      else
        if UnityEngine.op_Inequality(this.ViewGO, nil) then
          UnityEngine.Object.Destroy(this.ViewGO)
        end
      end

      this.status = DCET.EntityStatus.None
    end
    EndInit = function (this)
      System.try(function ()
        if this.childrenDB ~= nil then
          for _, child in System.each(this.childrenDB) do
            setIsComponent(child, false)
            AddChild(this, child)
            child.parent = this
          end
        end

        if this.componentsDB ~= nil then
          for _, component in System.each(this.componentsDB) do
            setIsComponent(component, true)
            AddToComponent(this, component:GetType(), component)
            component.parent = this
          end
        end
      end, function (default)
        local e = default
        DCET.Log.Error(e)
      end)
    end
    AddToComponentsDB = function (this, component)
      if this.componentsDB == nil then
        this.componentsDB = hashSetPool:Fetch()
      end

      this.componentsDB:Add(component)
    end
    RemoveFromComponentsDB = function (this, component)
      if this.componentsDB == nil then
        return
      end
      this.componentsDB:Remove(component)
      if this.componentsDB:getCount() == 0 and getIsFromPool(this) then
        hashSetPool:Recycle(this.componentsDB)
        this.componentsDB = nil
      end
    end
    AddToComponent = function (this, type, component)
      if this.components == nil then
        this.components = dictPool:Fetch()
      end

      this.components:AddKeyValue(type, component)

      if System.is(component, DCET.ISerializeToEntity) then
        AddToComponentsDB(this, component)
      end
    end
    RemoveFromComponent = function (this, type, component)
      if this.components == nil then
        return
      end

      this.components:RemoveKey(type)

      if this.components:getCount() == 0 and getIsFromPool(this) then
        dictPool:Recycle(this.components)
        this.components = nil
      end

      RemoveFromComponentsDB(this, component)
    end
    AddComponentWithInstance = function (this, component)
      setComponentParent(component, this)

      local type = component:GetType()

      AddToComponent(this, type, component)

      return component
    end
    AddComponentWithType = function (this, type)
      local component = CreateWithComponentParent(this, type)

      AddToComponent(this, type, component)

      return component
    end
    AddComponent = function (this, K)
      local type = System.typeof(K)

      local component = CreateWithComponentParent1(this, true, K)

      AddToComponent(this, type, component)

      return component
    end
    AddComponent1 = function (this, p1, K, P1)
      local type = System.typeof(K)

      local component = CreateWithComponentParent2(this, p1, true, K, P1)

      AddToComponent(this, type, component)

      return component
    end
    AddComponent2 = function (this, p1, p2, K, P1, P2)
      local type = System.typeof(K)

      local component = CreateWithComponentParent3(this, p1, p2, true, K, P1, P2)

      AddToComponent(this, type, component)

      return component
    end
    AddComponent3 = function (this, p1, p2, p3, K, P1, P2, P3)
      local type = System.typeof(K)

      local component = CreateWithComponentParent4(this, p1, p2, p3, true, K, P1, P2, P3)

      AddToComponent(this, type, component)

      return component
    end
    AddComponentNoPool = function (this, K)
      local type = System.typeof(K)

      local component = CreateWithComponentParent1(this, false, K)

      AddToComponent(this, type, component)

      return component
    end
    AddComponentNoPool1 = function (this, p1, K, P1)
      local type = System.typeof(K)

      local component = CreateWithComponentParent2(this, p1, false, K, P1)

      AddToComponent(this, type, component)

      return component
    end
    AddComponentNoPool2 = function (this, p1, p2, K, P1, P2)
      local type = System.typeof(K)

      local component = CreateWithComponentParent3(this, p1, p2, false, K, P1, P2)

      AddToComponent(this, type, component)

      return component
    end
    AddComponentNoPool3 = function (this, p1, p2, p3, K, P1, P2, P3)
      local type = System.typeof(K)

      local component = CreateWithComponentParent4(this, p1, p2, p3, false, K, P1, P2, P3)

      AddToComponent(this, type, component)

      return component
    end
    RemoveComponent = function (this, K)
      if getIsDisposed(this) then
        return
      end

      if this.components == nil then
        return
      end

      local type = System.typeof(K)
      local c = GetComponentWithType(this, type)
      if c == nil then
        return
      end

      RemoveFromComponent(this, type, c)
      c:Dispose()
    end
    RemoveComponentWithInstance = function (this, component)
      if getIsDisposed(this) then
        return
      end

      if this.components == nil then
        return
      end

      local type = component:GetType()
      local c = GetComponentWithType(this, component:GetType())
      if c == nil then
        return
      end
      if c.InstanceId ~= component.InstanceId then
        return
      end

      RemoveFromComponent(this, type, c)
      c:Dispose()
    end
    RemoveComponentWithType = function (this, type)
      if getIsDisposed(this) then
        return
      end

      local c = GetComponentWithType(this, type)
      if c == nil then
        return
      end

      RemoveFromComponent(this, type, c)
      c:Dispose()
    end
    GetComponent = function (this, K)
      if this.components == nil then
        return nil
      end
      local component
      local default
      default, component = this.components:TryGetValue(System.typeof(K))
      if not default then
        return nil --[[default(K)]]
      end
      return System.cast(K, component)
    end
    GetComponentWithType = function (this, type)
      if this.components == nil then
        return nil
      end
      local component
      local default
      default, component = this.components:TryGetValue(type)
      if not default then
        return nil
      end
      return component
    end
    CreateWithComponentParent = function (this, type)
      local component
      if type:IsDefined(System.typeof(DCET.NoObjectPool), false) then
        component = System.cast(class, System.Activator.CreateInstance(type))
      else
        component = DCET.Game.getObjectPool():Fetch(type)
      end

      setDomain(component, getDomain(this))
      component.Id = this.Id
      setComponentParent(component, this)

      DCET.Game.getEventSystem():Awake(component)
      return component
    end
    CreateWithComponentParent1 = function (this, isFromPool, T)
      local type = System.typeof(T)
      local component
      if not isFromPool then
        component = System.cast(class, System.Activator.CreateInstance(type))
      else
        component = DCET.Game.getObjectPool():Fetch(type)
      end
      setDomain(component, getDomain(this))
      component.Id = this.Id
      setComponentParent(component, this)

      DCET.Game.getEventSystem():Awake(component)
      return System.cast(T, component)
    end
    CreateWithComponentParent2 = function (this, a, isFromPool, T, A)
      local type = System.typeof(T)
      local component
      if not isFromPool then
        component = System.cast(class, System.Activator.CreateInstance(type))
      else
        component = DCET.Game.getObjectPool():Fetch(type)
      end
      setDomain(component, getDomain(this))
      component.Id = this.Id
      setComponentParent(component, this)

      DCET.Game.getEventSystem():Awake1(component, a, A)
      return System.cast(T, component)
    end
    CreateWithComponentParent3 = function (this, a, b, isFromPool, T, A, B)
      local type = System.typeof(T)
      local component
      if not isFromPool then
        component = System.cast(class, System.Activator.CreateInstance(type))
      else
        component = DCET.Game.getObjectPool():Fetch(type)
      end
      setDomain(component, getDomain(this))
      component.Id = this.Id
      setComponentParent(component, this)

      DCET.Game.getEventSystem():Awake2(component, a, b, A, B)
      return System.cast(T, component)
    end
    CreateWithComponentParent4 = function (this, a, b, c, isFromPool, T, A, B, C)
      local type = System.typeof(T)
      local component
      if not isFromPool then
        component = System.cast(class, System.Activator.CreateInstance(type))
      else
        component = DCET.Game.getObjectPool():Fetch(type)
      end
      setDomain(component, getDomain(this))
      component.Id = this.Id
      setComponentParent(component, this)

      DCET.Game.getEventSystem():Awake3(component, a, b, c, A, B, C)
      return System.cast(T, component)
    end
    class = {
      base = function (out)
        return {
          out.DCET.Object,
          System.IDisposable
        }
      end,
      InstanceId = 0,
      getIsFromPool = getIsFromPool,
      setIsFromPool = setIsFromPool,
      getIsDisposed = getIsDisposed,
      getParent = getParent,
      setParent = setParent,
      GetParent = GetParent,
      ToString = ToString,
      Id = 0,
      getDomain = getDomain,
      setDomain = setDomain,
      getChildren = getChildren,
      getComponents = getComponents,
      Dispose = Dispose,
      EndInit = EndInit,
      AddComponentWithInstance = AddComponentWithInstance,
      AddComponentWithType = AddComponentWithType,
      AddComponent = AddComponent,
      AddComponent1 = AddComponent1,
      AddComponent2 = AddComponent2,
      AddComponent3 = AddComponent3,
      AddComponentNoPool = AddComponentNoPool,
      AddComponentNoPool1 = AddComponentNoPool1,
      AddComponentNoPool2 = AddComponentNoPool2,
      AddComponentNoPool3 = AddComponentNoPool3,
      RemoveComponent = RemoveComponent,
      RemoveComponentWithInstance = RemoveComponentWithInstance,
      RemoveComponentWithType = RemoveComponentWithType,
      GetComponent = GetComponent,
      GetComponentWithType = GetComponentWithType,
      static = static,
      __ctor__ = __ctor__,
      __metadata__ = function (out)
        return {
          properties = {
            { "Children", 0x206, System.Dictionary(System.Int64, out.DCET.Entity), getChildren, out.MongoDB.Bson.Serialization.Attributes.BsonIgnoreAttribute() },
            { "ComponentParent", 0x301, class, setComponentParent, out.MongoDB.Bson.Serialization.Attributes.BsonIgnoreAttribute() },
            { "Components", 0x206, System.Dictionary(System.Type, out.DCET.Entity), getComponents, out.MongoDB.Bson.Serialization.Attributes.BsonIgnoreAttribute() },
            { "Domain", 0x106, class, getDomain, setDomain, out.MongoDB.Bson.Serialization.Attributes.BsonIgnoreAttribute() },
            { "Id", 0x6, System.Int64, out.MongoDB.Bson.Serialization.Attributes.BsonIgnoreIfDefaultAttribute(), out.MongoDB.Bson.Serialization.Attributes.BsonDefaultValueAttribute(0), out.MongoDB.Bson.Serialization.Attributes.BsonElementAttribute(), out.MongoDB.Bson.Serialization.Attributes.BsonIdAttribute() },
            { "InstanceId", 0x6, System.Int64, out.MongoDB.Bson.Serialization.Attributes.BsonIgnoreAttribute() },
            { "IsComponent", 0x101, System.Boolean, getIsComponent, setIsComponent, out.MongoDB.Bson.Serialization.Attributes.BsonIgnoreAttribute() },
            { "IsDisposed", 0x206, System.Boolean, getIsDisposed, out.MongoDB.Bson.Serialization.Attributes.BsonIgnoreAttribute() },
            { "IsFromPool", 0x106, System.Boolean, getIsFromPool, setIsFromPool, out.MongoDB.Bson.Serialization.Attributes.BsonIgnoreAttribute() },
            { "IsRegister", 0x101, System.Boolean, getIsRegister, setIsRegister, out.MongoDB.Bson.Serialization.Attributes.BsonIgnoreAttribute() },
            { "Parent", 0x106, class, getParent, setParent, out.MongoDB.Bson.Serialization.Attributes.BsonIgnoreAttribute() },
            { "ViewGO", 0x6, out.UnityEngine.GameObject, out.MongoDB.Bson.Serialization.Attributes.BsonIgnoreAttribute() }
          },
          fields = {
            { "children", 0x1, System.Dictionary(System.Int64, out.DCET.Entity), out.MongoDB.Bson.Serialization.Attributes.BsonIgnoreAttribute() },
            { "childrenDB", 0x1, System.HashSet(out.DCET.Entity), out.MongoDB.Bson.Serialization.Attributes.BsonElementAttribute("Children"), out.MongoDB.Bson.Serialization.Attributes.BsonIgnoreIfNullAttribute() },
            { "components", 0x1, System.Dictionary(System.Type, out.DCET.Entity), out.MongoDB.Bson.Serialization.Attributes.BsonIgnoreAttribute() },
            { "componentsDB", 0x1, System.HashSet(out.DCET.Entity), out.MongoDB.Bson.Serialization.Attributes.BsonElementAttribute("C"), out.MongoDB.Bson.Serialization.Attributes.BsonIgnoreIfNullAttribute() },
            { "domain", 0x3, class, out.MongoDB.Bson.Serialization.Attributes.BsonIgnoreAttribute() },
            { "parent", 0x3, class, out.MongoDB.Bson.Serialization.Attributes.BsonIgnoreAttribute() },
            { "status", 0x1, System.Int32, out.MongoDB.Bson.Serialization.Attributes.BsonIgnoreAttribute() }
          }
        }
      end
    }
    return class
  end)
end)
