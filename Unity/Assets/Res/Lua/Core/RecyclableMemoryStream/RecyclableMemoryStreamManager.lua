-- Generated by CSharp.lua Compiler
-- ---------------------------------------------------------------------
-- Copyright (c) 2015-2016 Microsoft
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in
-- all copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-- THE SOFTWARE.
-- ---------------------------------------------------------------------
local System = System
local Linq = System.Linq.Enumerable
local SystemConcurrent = System.Collections.Concurrent
local ArrayByte = System.Array(System.Byte)
local ArrayInt64 = System.Array(System.Int64)
local ConcurrentStack_1ArrayByte = SystemConcurrent.ConcurrentStack_1(ArrayByte)
local ArrayConcurrentStack_1ArrayByte = System.Array(ConcurrentStack_1ArrayByte)
local MicrosoftIO
System.import(function (out)
  MicrosoftIO = Microsoft.IO
end)
System.namespace("Microsoft.IO", function (namespace)
  -- <summary>
  -- Manages pools of RecyclableMemoryStream objects.
  -- </summary>
  -- There are two pools managed in here. The small pool contains same-sized buffers that are handed to streams
  -- as they write more data.
  -- 
  -- For scenarios that need to call GetBuffer(), the large pool contains buffers of various sizes, all
  -- multiples of LargeBufferMultiple (1 MB by default). They are split by size to avoid overly-wasteful buffer
  -- usage. There should be far fewer 8 MB buffers than 1 MB buffers, for example.
  -- </remarks>
  namespace.class("RecyclableMemoryStreamManager", function (namespace)
    local getBlockSize, getLargeBufferMultiple, getMaximumBufferSize, getSmallPoolFreeSize, getSmallPoolInUseSize, getLargePoolFreeSize, getLargePoolInUseSize, getSmallBlocksFree, 
    getLargeBuffersFree, GetBlock, GetLargeBuffer, RoundToLargeBufferMultiple, IsLargeBufferMultiple, ReturnLargeBuffer, ReturnBlocks, ReportBlockCreated, 
    ReportBlockDiscarded, ReportLargeBufferCreated, ReportLargeBufferDiscarded, ReportStreamCreated, ReportStreamDisposed, ReportStreamFinalized, ReportStreamLength, ReportStreamToArray, 
    ReportUsageReport, GetStream, GetStream1, GetStream2, GetStream3, GetStream4, class, __ctor1__, 
    __ctor2__
    namespace.class("Events", function (namespace)
      local MemoryStreamCreated, MemoryStreamDisposed, MemoryStreamDoubleDispose, MemoryStreamFinalized, MemoryStreamToArray, MemoryStreamManagerInitialized, MemoryStreamNewBlockCreated, MemoryStreamNewLargeBufferCreated, 
      MemoryStreamNonPooledLargeBufferCreated, MemoryStreamDiscardBuffer, MemoryStreamOverCapacity, class, static, __ctor__
      static = function (this)
        this.Writer = class()
      end
      __ctor__ = function (this)
        System.base(this).__ctor__(this)
      end
      MemoryStreamCreated = function (this, guid, tag, requestedSize)
        if this:IsEnabled(5 --[[EventLevel.Verbose]], 0 --[[EventKeywords.None]]) then
          this:WriteEvent(1, guid, tag or (""), requestedSize)
        end
      end
      MemoryStreamDisposed = function (this, guid, tag)
        if this:IsEnabled(5 --[[EventLevel.Verbose]], 0 --[[EventKeywords.None]]) then
          this:WriteEvent(2, guid, tag or (""))
        end
      end
      MemoryStreamDoubleDispose = function (this, guid, tag, allocationStack, disposeStack1, disposeStack2)
        if this:IsEnabled() then
          this:WriteEvent(3, guid, tag or (""), allocationStack or (""), disposeStack1 or (""), disposeStack2 or (""))
        end
      end
      MemoryStreamFinalized = function (this, guid, tag, allocationStack)
        if this:IsEnabled() then
          this:WriteEvent(4, guid, tag or (""), allocationStack or (""))
        end
      end
      MemoryStreamToArray = function (this, guid, tag, stack, size)
        if this:IsEnabled(5 --[[EventLevel.Verbose]], 0 --[[EventKeywords.None]]) then
          this:WriteEvent(5, guid, tag or (""), stack or (""), size)
        end
      end
      MemoryStreamManagerInitialized = function (this, blockSize, largeBufferMultiple, maximumBufferSize)
        if this:IsEnabled() then
          this:WriteEvent(6, blockSize, largeBufferMultiple, maximumBufferSize)
        end
      end
      MemoryStreamNewBlockCreated = function (this, smallPoolInUseBytes)
        if this:IsEnabled(5 --[[EventLevel.Verbose]], 0 --[[EventKeywords.None]]) then
          this:WriteEvent(7, smallPoolInUseBytes)
        end
      end
      MemoryStreamNewLargeBufferCreated = function (this, requiredSize, largePoolInUseBytes)
        if this:IsEnabled(5 --[[EventLevel.Verbose]], 0 --[[EventKeywords.None]]) then
          this:WriteEvent(8, requiredSize, largePoolInUseBytes)
        end
      end
      MemoryStreamNonPooledLargeBufferCreated = function (this, requiredSize, tag, allocationStack)
        if this:IsEnabled(5 --[[EventLevel.Verbose]], 0 --[[EventKeywords.None]]) then
          this:WriteEvent(9, requiredSize, tag or (""), allocationStack or (""))
        end
      end
      MemoryStreamDiscardBuffer = function (this, bufferType, tag, reason)
        if this:IsEnabled() then
          this:WriteEvent(10, bufferType, tag or (""), reason)
        end
      end
      MemoryStreamOverCapacity = function (this, requestedCapacity, maxCapacity, tag, allocationStack)
        if this:IsEnabled() then
          this:WriteEvent(11, requestedCapacity, maxCapacity, tag or (""), allocationStack or (""))
        end
      end
      class = {
        base = function (out, this)
          local base = System.Diagnostics.Tracing.EventSource
          this.__gc = base.__gc
          return {
            base
          }
        end,
        MemoryStreamCreated = MemoryStreamCreated,
        MemoryStreamDisposed = MemoryStreamDisposed,
        MemoryStreamDoubleDispose = MemoryStreamDoubleDispose,
        MemoryStreamFinalized = MemoryStreamFinalized,
        MemoryStreamToArray = MemoryStreamToArray,
        MemoryStreamManagerInitialized = MemoryStreamManagerInitialized,
        MemoryStreamNewBlockCreated = MemoryStreamNewBlockCreated,
        MemoryStreamNewLargeBufferCreated = MemoryStreamNewLargeBufferCreated,
        MemoryStreamNonPooledLargeBufferCreated = MemoryStreamNonPooledLargeBufferCreated,
        MemoryStreamDiscardBuffer = MemoryStreamDiscardBuffer,
        MemoryStreamOverCapacity = MemoryStreamOverCapacity,
        static = static,
        __ctor__ = __ctor__,
        __metadata__ = function (out)
          return {
            methods = {
              { "MemoryStreamCreated", 0x306, MemoryStreamCreated, System.Guid, System.String, System.Int32, System.apply(System.Diagnostics.Tracing.EventAttribute(1), function (default) default:setLevel(5 --[[EventLevel.Verbose]]) end) },
              { "MemoryStreamDiscardBuffer", 0x306, MemoryStreamDiscardBuffer, System.Int32, System.String, System.Int32, System.apply(System.Diagnostics.Tracing.EventAttribute(10), function (default) default:setLevel(3 --[[EventLevel.Warning]]) end) },
              { "MemoryStreamDisposed", 0x206, MemoryStreamDisposed, System.Guid, System.String, System.apply(System.Diagnostics.Tracing.EventAttribute(2), function (default) default:setLevel(5 --[[EventLevel.Verbose]]) end) },
              { "MemoryStreamDoubleDispose", 0x506, MemoryStreamDoubleDispose, System.Guid, System.String, System.String, System.String, System.String, System.apply(System.Diagnostics.Tracing.EventAttribute(3), function (default) default:setLevel(1 --[[EventLevel.Critical]]) end) },
              { "MemoryStreamFinalized", 0x306, MemoryStreamFinalized, System.Guid, System.String, System.String, System.apply(System.Diagnostics.Tracing.EventAttribute(4), function (default) default:setLevel(2 --[[EventLevel.Error]]) end) },
              { "MemoryStreamManagerInitialized", 0x306, MemoryStreamManagerInitialized, System.Int32, System.Int32, System.Int32, System.apply(System.Diagnostics.Tracing.EventAttribute(6), function (default) default:setLevel(4 --[[EventLevel.Informational]]) end) },
              { "MemoryStreamNewBlockCreated", 0x106, MemoryStreamNewBlockCreated, System.Int64, System.apply(System.Diagnostics.Tracing.EventAttribute(7), function (default) default:setLevel(5 --[[EventLevel.Verbose]]) end) },
              { "MemoryStreamNewLargeBufferCreated", 0x206, MemoryStreamNewLargeBufferCreated, System.Int32, System.Int64, System.apply(System.Diagnostics.Tracing.EventAttribute(8), function (default) default:setLevel(5 --[[EventLevel.Verbose]]) end) },
              { "MemoryStreamNonPooledLargeBufferCreated", 0x306, MemoryStreamNonPooledLargeBufferCreated, System.Int32, System.String, System.String, System.apply(System.Diagnostics.Tracing.EventAttribute(9), function (default) default:setLevel(5 --[[EventLevel.Verbose]]) end) },
              { "MemoryStreamOverCapacity", 0x406, MemoryStreamOverCapacity, System.Int32, System.Int64, System.String, System.String, System.apply(System.Diagnostics.Tracing.EventAttribute(11), function (default) default:setLevel(2 --[[EventLevel.Error]]) end) },
              { "MemoryStreamToArray", 0x406, MemoryStreamToArray, System.Guid, System.String, System.String, System.Int32, System.apply(System.Diagnostics.Tracing.EventAttribute(5), function (default) default:setLevel(5 --[[EventLevel.Verbose]]) end) }
            },
            class = { 0x6, System.apply(System.Diagnostics.Tracing.EventSourceAttribute(), function (default) default:setName("Microsoft-IO-RecyclableMemoryStream")default:setGuid("{B80CD4E4-890E-468D-9CBA-90EB7C82DFC7}") end) }
          }
        end
      }
      return class
    end)
    -- <summary>
    -- Initializes the memory manager with the default block/buffer specifications.
    -- </summary>
    __ctor1__ = function (this)
      __ctor2__(this, 131072 --[[RecyclableMemoryStreamManager.DefaultBlockSize]], 1048576 --[[RecyclableMemoryStreamManager.DefaultLargeBufferMultiple]], 134217728 --[[RecyclableMemoryStreamManager.DefaultMaximumBufferSize]])
    end
    -- <summary>
    -- Initializes the memory manager with the given block requiredSize.
    -- </summary>
    -- <param name="largeBufferMultiple">Each large buffer will be a multiple of this value.</param>
    -- <param name="maximumBufferSize">Buffers larger than this are not pooled</param>
    -- <exception cref="ArgumentOutOfRangeException">blockSize is not a positive number, or largeBufferMultiple is not a positive number, or maximumBufferSize is less than blockSize.</exception>
    -- <exception cref="ArgumentException">maximumBufferSize is not a multiple of largeBufferMultiple</exception>
    __ctor2__ = function (this, blockSize, largeBufferMultiple, maximumBufferSize)
      if blockSize <= 0 then
        System.throw(System.ArgumentOutOfRangeException("blockSize" --[[nameof(blockSize)]], nil, nil, blockSize, "blockSize must be a positive number"))
      end

      if largeBufferMultiple <= 0 then
        System.throw(System.ArgumentOutOfRangeException("largeBufferMultiple" --[[nameof(largeBufferMultiple)]], "largeBufferMultiple must be a positive number"))
      end

      if maximumBufferSize < blockSize then
        System.throw(System.ArgumentOutOfRangeException("maximumBufferSize" --[[nameof(maximumBufferSize)]], "maximumBufferSize must be at least blockSize"))
      end

      this.blockSize = blockSize
      this.largeBufferMultiple = largeBufferMultiple
      this.maximumBufferSize = maximumBufferSize

      if not IsLargeBufferMultiple(this, maximumBufferSize) then
        System.throw(System.ArgumentException("maximumBufferSize is not a multiple of largeBufferMultiple", "maximumBufferSize" --[[nameof(maximumBufferSize)]]))
      end

      this.smallPool = ConcurrentStack_1ArrayByte()
      local numLargePools = System.div(maximumBufferSize, largeBufferMultiple)

      -- +1 to store size of bytes in use that are too large to be pooled
      this.largeBufferInUseSize = ArrayInt64:new(numLargePools + 1)
      this.largeBufferFreeSize = ArrayInt64:new(numLargePools)

      this.largePools = ArrayConcurrentStack_1ArrayByte:new(numLargePools)

      for i = 0, #this.largePools - 1 do
        this.largePools:set(i, ConcurrentStack_1ArrayByte())
      end

      class.Events.Writer:MemoryStreamManagerInitialized(blockSize, largeBufferMultiple, maximumBufferSize)
    end
    getBlockSize = function (this)
      return this.blockSize
    end
    getLargeBufferMultiple = function (this)
      return this.largeBufferMultiple
    end
    getMaximumBufferSize = function (this)
      return this.maximumBufferSize
    end
    getSmallPoolFreeSize = function (this)
      return this.smallPoolFreeSize
    end
    getSmallPoolInUseSize = function (this)
      return this.smallPoolInUseSize
    end
    getLargePoolFreeSize = function (this)
      return Linq.Sum(this.largeBufferFreeSize)
    end
    getLargePoolInUseSize = function (this)
      return Linq.Sum(this.largeBufferInUseSize)
    end
    getSmallBlocksFree = function (this)
      return this.smallPool:getCount()
    end
    getLargeBuffersFree = function (this)
      local free = 0
      for _, pool in System.each(this.largePools) do
        free = free + pool:getCount()
      end
      return free
    end
    -- <summary>
    -- Removes and returns a single block from the pool.
    -- </summary>
    GetBlock = function (this)
      local block
      local default
      default, block = this.smallPool:TryPop()
      if not default then
        -- We'll add this back to the pool when the stream is disposed
        -- (unless our free pool is too large)
        block = ArrayByte:new(getBlockSize(this))
        class.Events.Writer:MemoryStreamNewBlockCreated(this.smallPoolInUseSize)
        ReportBlockCreated(this)
      else
        local _
        _, this.smallPoolFreeSize = System.Interlocked.Add(this.smallPoolFreeSize, - getBlockSize(this))
      end

      local _
      _, this.smallPoolInUseSize = System.Interlocked.Add(this.smallPoolInUseSize, getBlockSize(this))
      return block
    end
    -- <summary>
    -- Returns a buffer of arbitrary size from the large buffer pool. This buffer
    -- will be at least the requiredSize and always be a multiple of largeBufferMultiple.
    -- </summary>
    -- <param name="tag">The tag of the stream returning this buffer, for logging if necessary.</param>
    -- <returns>A buffer of at least the required size.</returns>
    GetLargeBuffer = function (this, requiredSize, tag)
      requiredSize = RoundToLargeBufferMultiple(this, requiredSize)

      local poolIndex = System.div(requiredSize, this.largeBufferMultiple) - 1

      local buffer
      if poolIndex < #this.largePools then
        local default
        default, buffer = this.largePools:get(poolIndex):TryPop()
        if not default then
          buffer = ArrayByte:new(requiredSize)

          class.Events.Writer:MemoryStreamNewLargeBufferCreated(requiredSize, getLargePoolInUseSize(this))
          ReportLargeBufferCreated(this)
        else
          local _, extern = System.Interlocked.Add(this.largeBufferFreeSize:get(poolIndex), - #buffer)
          this.largeBufferFreeSize:set(poolIndex, extern)
        end
      else
        -- Buffer is too large to pool. They get a new buffer.

        -- We still want to track the size, though, and we've reserved a slot
        -- in the end of the inuse array for nonpooled bytes in use.
        poolIndex = #this.largeBufferInUseSize - 1

        -- We still want to round up to reduce heap fragmentation.
        buffer = ArrayByte:new(requiredSize)
        local callStack = nil
        if this.GenerateCallStacks then
          -- Grab the stack -- we want to know who requires such large buffers
          callStack = System.Environment.getStackTrace()
        end
        class.Events.Writer:MemoryStreamNonPooledLargeBufferCreated(requiredSize, tag, callStack)
        ReportLargeBufferCreated(this)
      end

      local _, default = System.Interlocked.Add(this.largeBufferInUseSize:get(poolIndex), #buffer)
      this.largeBufferInUseSize:set(poolIndex, default)

      return buffer
    end
    RoundToLargeBufferMultiple = function (this, requiredSize)
      return (System.div((requiredSize + getLargeBufferMultiple(this) - 1), getLargeBufferMultiple(this))) * getLargeBufferMultiple(this)
    end
    IsLargeBufferMultiple = function (this, value)
      return (value ~= 0) and (System.mod(value, getLargeBufferMultiple(this))) == 0
    end
    -- <summary>
    -- Returns the buffer to the large pool
    -- </summary>
    -- <param name="tag">The tag of the stream returning this buffer, for logging if necessary.</param>
    -- <exception cref="ArgumentNullException">buffer is null</exception>
    -- <exception cref="ArgumentException">buffer.Length is not a multiple of LargeBufferMultiple (it did not originate from this pool)</exception>
    ReturnLargeBuffer = function (this, buffer, tag)
      if buffer == nil then
        System.throw(System.ArgumentNullException("buffer" --[[nameof(buffer)]]))
      end

      if not IsLargeBufferMultiple(this, #buffer) then
        System.throw(System.ArgumentException("buffer did not originate from this memory manager. The size is not a multiple of " .. getLargeBufferMultiple(this)))
      end

      local poolIndex = System.div(#buffer, this.largeBufferMultiple) - 1

      if poolIndex < #this.largePools then
        if (this.largePools:get(poolIndex):getCount() + 1) * #buffer <= this.MaximumFreeLargePoolBytes or this.MaximumFreeLargePoolBytes == 0 then
          this.largePools:get(poolIndex):Push(buffer)
          local _, default = System.Interlocked.Add(this.largeBufferFreeSize:get(poolIndex), #buffer)
          this.largeBufferFreeSize:set(poolIndex, default)
        else
          class.Events.Writer:MemoryStreamDiscardBuffer(1 --[[MemoryStreamBufferType.Large]], tag, 1 --[[MemoryStreamDiscardReason.EnoughFree]])
          ReportLargeBufferDiscarded(this, 1 --[[MemoryStreamDiscardReason.EnoughFree]])
        end
      else
        -- This is a non-poolable buffer, but we still want to track its size for inuse
        -- analysis. We have space in the inuse array for this.
        poolIndex = #this.largeBufferInUseSize - 1

        class.Events.Writer:MemoryStreamDiscardBuffer(1 --[[MemoryStreamBufferType.Large]], tag, 0 --[[MemoryStreamDiscardReason.TooLarge]])
        ReportLargeBufferDiscarded(this, 0 --[[MemoryStreamDiscardReason.TooLarge]])
      end

      local _, default = System.Interlocked.Add(this.largeBufferInUseSize:get(poolIndex), - #buffer)
      this.largeBufferInUseSize:set(poolIndex, default)

      ReportUsageReport(this, this.smallPoolInUseSize, this.smallPoolFreeSize, getLargePoolInUseSize(this), getLargePoolFreeSize(this))
    end
    -- <summary>
    -- Returns the blocks to the pool
    -- </summary>
    -- <param name="tag">The tag of the stream returning these blocks, for logging if necessary.</param>
    -- <exception cref="ArgumentNullException">blocks is null</exception>
    -- <exception cref="ArgumentException">blocks contains buffers that are the wrong size (or null) for this memory manager</exception>
    ReturnBlocks = function (this, blocks, tag)
      if blocks == nil then
        System.throw(System.ArgumentNullException("blocks" --[[nameof(blocks)]]))
      end

      local bytesToReturn = blocks:getCount() * getBlockSize(this)
      local _
      _, this.smallPoolInUseSize = System.Interlocked.Add(this.smallPoolInUseSize, - bytesToReturn)

      for _, block in System.each(blocks) do
        if block == nil or #block ~= getBlockSize(this) then
          System.throw(System.ArgumentException("blocks contains buffers that are not BlockSize in length"))
        end
      end

      for _, block in System.each(blocks) do
        if this.MaximumFreeSmallPoolBytes == 0 or getSmallPoolFreeSize(this) < this.MaximumFreeSmallPoolBytes then
          local _
          _, this.smallPoolFreeSize = System.Interlocked.Add(this.smallPoolFreeSize, getBlockSize(this))
          this.smallPool:Push(block)
        else
          class.Events.Writer:MemoryStreamDiscardBuffer(0 --[[MemoryStreamBufferType.Small]], tag, 1 --[[MemoryStreamDiscardReason.EnoughFree]])
          ReportBlockDiscarded(this)
          break
        end
      end

      ReportUsageReport(this, this.smallPoolInUseSize, this.smallPoolFreeSize, getLargePoolInUseSize(this), getLargePoolFreeSize(this))
    end
    ReportBlockCreated = function (this)
      local default = this.BlockCreated
      if default ~= nil then
        default()
      end
    end
    ReportBlockDiscarded = function (this)
      local default = this.BlockDiscarded
      if default ~= nil then
        default()
      end
    end
    ReportLargeBufferCreated = function (this)
      local default = this.LargeBufferCreated
      if default ~= nil then
        default()
      end
    end
    ReportLargeBufferDiscarded = function (this, reason)
      local default = this.LargeBufferDiscarded
      if default ~= nil then
        default(reason)
      end
    end
    ReportStreamCreated = function (this)
      local default = this.StreamCreated
      if default ~= nil then
        default()
      end
    end
    ReportStreamDisposed = function (this)
      local default = this.StreamDisposed
      if default ~= nil then
        default()
      end
    end
    ReportStreamFinalized = function (this)
      local default = this.StreamFinalized
      if default ~= nil then
        default()
      end
    end
    ReportStreamLength = function (this, bytes)
      local default = this.StreamLength
      if default ~= nil then
        default(bytes)
      end
    end
    ReportStreamToArray = function (this)
      local default = this.StreamConvertedToArray
      if default ~= nil then
        default()
      end
    end
    ReportUsageReport = function (this, smallPoolInUseBytes, smallPoolFreeBytes, largePoolInUseBytes, largePoolFreeBytes)
      local default = this.UsageReport
      if default ~= nil then
        default(smallPoolInUseBytes, smallPoolFreeBytes, largePoolInUseBytes, largePoolFreeBytes)
      end
    end
    -- <summary>
    -- Retrieve a new MemoryStream object with no tag and a default initial capacity.
    -- </summary>
    GetStream = function (this)
      return MicrosoftIO.RecyclableMemoryStream(this)
    end
    -- <summary>
    -- Retrieve a new MemoryStream object with the given tag and a default initial capacity.
    -- </summary>
    -- <returns>A MemoryStream.</returns>
    GetStream1 = function (this, tag)
      return System.new(MicrosoftIO.RecyclableMemoryStream, 2, this, tag)
    end
    -- <summary>
    -- Retrieve a new MemoryStream object with the given tag and at least the given capacity.
    -- </summary>
    -- <param name="requiredSize">The minimum desired capacity for the stream.</param>
    -- <returns>A MemoryStream.</returns>
    GetStream2 = function (this, tag, requiredSize)
      return System.new(MicrosoftIO.RecyclableMemoryStream, 3, this, tag, requiredSize)
    end
    -- <summary>
    -- Retrieve a new MemoryStream object with the given tag and at least the given capacity, possibly using
    -- a single continugous underlying buffer.
    -- </summary>
    -- where the initial size is known and it is desirable to avoid copying data between the smaller underlying
    -- buffers to a single large one. This is most helpful when you know that you will always call GetBuffer
    -- on the underlying stream.</remarks>
    -- <param name="tag">A tag which can be used to track the source of the stream.</param>
    -- <param name="requiredSize">The minimum desired capacity for the stream.</param>
    -- <param name="asContiguousBuffer">Whether to attempt to use a single contiguous buffer.</param>
    -- <returns>A MemoryStream.</returns>
    GetStream3 = function (this, tag, requiredSize, asContiguousBuffer)
      if not asContiguousBuffer or requiredSize <= getBlockSize(this) then
        return GetStream2(this, tag, requiredSize)
      end

      return System.new(MicrosoftIO.RecyclableMemoryStream, 4, this, tag, requiredSize, GetLargeBuffer(this, requiredSize, tag))
    end
    -- <summary>
    -- Retrieve a new MemoryStream object with the given tag and with contents copied from the provided
    -- buffer. The provided buffer is not wrapped or used after construction.
    -- </summary>
    -- <param name="tag">A tag which can be used to track the source of the stream.</param>
    -- <param name="buffer">The byte buffer to copy data from.</param>
    -- <param name="offset">The offset from the start of the buffer to copy from.</param>
    -- <param name="count">The number of bytes to copy from the buffer.</param>
    -- <returns>A MemoryStream.</returns>
    GetStream4 = function (this, tag, buffer, offset, count)
      local stream = System.new(MicrosoftIO.RecyclableMemoryStream, 3, this, tag, count)
      stream:Write(buffer, offset, count)
      stream:setPosition(0)
      return stream
    end
    class = {
      blockSize = 0,
      largeBufferMultiple = 0,
      maximumBufferSize = 0,
      smallPoolFreeSize = 0,
      smallPoolInUseSize = 0,
      getBlockSize = getBlockSize,
      getLargeBufferMultiple = getLargeBufferMultiple,
      getMaximumBufferSize = getMaximumBufferSize,
      getSmallPoolFreeSize = getSmallPoolFreeSize,
      getSmallPoolInUseSize = getSmallPoolInUseSize,
      getLargePoolFreeSize = getLargePoolFreeSize,
      getLargePoolInUseSize = getLargePoolInUseSize,
      getSmallBlocksFree = getSmallBlocksFree,
      getLargeBuffersFree = getLargeBuffersFree,
      MaximumFreeSmallPoolBytes = 0,
      MaximumFreeLargePoolBytes = 0,
      MaximumStreamCapacity = 0,
      GenerateCallStacks = false,
      AggressiveBufferReturn = false,
      GetBlock = GetBlock,
      GetLargeBuffer = GetLargeBuffer,
      ReturnLargeBuffer = ReturnLargeBuffer,
      ReturnBlocks = ReturnBlocks,
      ReportBlockCreated = ReportBlockCreated,
      ReportBlockDiscarded = ReportBlockDiscarded,
      ReportLargeBufferCreated = ReportLargeBufferCreated,
      ReportLargeBufferDiscarded = ReportLargeBufferDiscarded,
      ReportStreamCreated = ReportStreamCreated,
      ReportStreamDisposed = ReportStreamDisposed,
      ReportStreamFinalized = ReportStreamFinalized,
      ReportStreamLength = ReportStreamLength,
      ReportStreamToArray = ReportStreamToArray,
      ReportUsageReport = ReportUsageReport,
      GetStream = GetStream,
      GetStream1 = GetStream1,
      GetStream2 = GetStream2,
      GetStream3 = GetStream3,
      GetStream4 = GetStream4,
      __ctor__ = {
        __ctor1__,
        __ctor2__
      },
      __metadata__ = function (out)
        return {
          methods = {
            { "GetStream", 0x486, GetStream4, System.String, System.Array(System.Byte), System.Int32, System.Int32, System.IO.MemoryStream, System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Reliability", "CA2000:Dispose objects before losing scope") }
          }
        }
      end
    }
    return class
  end)
end)
